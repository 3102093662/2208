# import和export 的使用

node编程中最重要的思想就是模块化，import和export都是被模块化所使用，在es6当中，用export导出接口用import引入模块，但是在node模块中，使用module.exports导出模块，使用require引入模块

两者的区别如下

## 遵循规范：

​	require是AMD规范引入方式

​	import是编译时调用，所有必须放在文件开头

## 本质 

​	require是赋值过程，module.exports后面的内容是什么，require的结果就是什么，比如对象、数字、字符串、函数等，然后把require结果赋值给某个变量，它相当于module。exports的传送门

​	import是解构过程，但是目前所有的引擎都没有实现import，我们在node中使用babel支持ES6,也仅仅是将ES6转码为ES5在执行，import语法会被转码为require

import虽然是es6中的语法，但就目前来说，所有的引擎都没实现import

babel是将es6的语法转换为es5，使浏览器可以编译出来

我们在node中使用babel支持ES6(在node当中，比如node.js代码，也不能直接使用import来导入，必须使用babel支持才能使用import语法)，实际上也是将ES6转码为ES5再执行，import语法实际上会被转码为require，这也是为什么再模块导出时使module.exports，在引入时使用import仍然起效，因为本质上，import会被转码为require去执行

## require() | exports的用法

通过require引入基础数据类型时，属于赋值变量，通过require引入复杂数据类型时，属于浅拷贝该对象

import是编译时运行的(require是运行时的),它必须放在文件开头，而且使用格式也是确定的，不容置疑，它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多

import | export 遵循ES6规范，支持编译时静态分析，便于js引入宏和类型检验。动态绑定，写法较多

# proxy

## 	概念

​		proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）

##    语法

```js
const p =new Proxy(target,handler)
target
要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
handler
一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理P的行为
```

handler（en-US）

包含捕捉器（trap）的占位符对象，可译为处理器对象

traps

提供属性访问的方法，这类似与操作系统中捕获器的概念

target

被proxy代理虚拟化的对象，它常被作为代理的存储后端，根据目标验证关于对象不可扩展性或不可配置性的不变量（保持不变的语义）

# set和map的区别

## 简述

set和map主要的应用场景在于数据重组和数据存储

set是一种叫做集合的数据结构，

map是一种叫做字典的数据结构

## 集合与字典的区别

共同点：集合、字典可以储存不重复的值

不同的：集合是以[value，value]的形式存储元素，字典是以[key,value]的形式存储

集合（set）

ES6新增的一种新的数据结构，类似于数组，成员唯一（内部元素没有重复的值）。且使用

## 数据配许即顺序存储

set本身是一种构造函数，用来生成set数据结构

set对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用

注意：向set加入值的时候，不会发生类型，所以5和"5"是两个不同的值，set内部判断两个值是否不同，使用的算法叫做"Sanme-value-zero equality"，它类似于精确相等运算符(=)，主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身，另外NaN和undefined都可以被存储在set中，NaN之间被视为相同的值(NaN被认为是相同的，尽管NaN！NaN)

方法：

add(value) 新增，相当于array里的push

delete(value)：存在即删除集合中value

has(value)：判断集合中是否存在value

clear ()：清空集合

遍历方法：遍历顺序为插入顺序

keys()返回一个包含集合中所有键的迭代器

values()：返回一个包含集合中所有值的迭代器

entries()：返回一个包含set对象中所有元素的键值对迭代器

froEach(callbackFn,thisArg)：用于对集合成员执行callbackFn操作，如果提供lthisArg参数，回调中的this会是这个参数，没有返回值

## weakset

weakset对象允许你将弱引用对象存储在一个集合中

weakset与set的区别

weakset只能存储对象引用，不能存放值，而set都可以

weakset对象中存储的对象值都是被弱引用的，即垃圾回收机制不考虑weakset对该对象的引用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉(不考虑该对象还存在与weakset中)所有，weakset对象里有多少个成员元素，取决于垃圾回收机制有没有执行，运行前后成员个数可能不一致，遍历结束之后，有点成员可能取不到了(被垃圾回收了)，weakset对象是无法被遍历的(ES6规定weakset不可遍历)，也没有办法拿到它包含的所有元素

# 小程序

## swiper  轮播图 

| 属相                   | 类型    | 默认值        | 说明               |
| ---------------------- | ------- | ------------- | ------------------ |
| indicator-dots         | Boolean | false         | 是否显示面板指示点 |
| indicator-color        | color   | rgba(0,0,0.3) | 指示点颜色         |
| indicator-active-color | color   | #000          | 选中的颜色         |
| autoplay               | Boolean | false         | 自动切换           |
| interval               | number  | 5000          | 间隔时间           |
| circular               | Boolean | false         | 切换衔接           |

## image 图片 mode属性  控制图片宽高

| mode值      | 说明                                                |
| ----------- | --------------------------------------------------- |
| scaleToFill | 默认值，占满image                                   |
| aspectFit   | 自适应，让较长的一边完全显示出来 ，宽高依然是默认值 |
| aspectFill  | 自适应，让短的一边完全显示出来......                |
| widthFix    | 依据宽度自适应比例缩放                              |
| heightFix   | 依据高度自适应比例缩放                              |

## 小程序的版本

| 版本阶段     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 开发版本     | 使用开发者工具,可将代码上传到开发版本中,开发版本只保留每人最新的一份上传的代码。点击提交审核,可将代码提交审核,开发版本可删除,不影响线上版本和审核中版本的代码 |
| 体验版本     | 可以选择某个开发版本作为体验版，并且选取一份体验版           |
| 审核中的版本 | 只能有一份代码处于审核中，有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本 |
| 线上版本     | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新 |

# 事件冒泡和事件捕获

![1685877005231](https://ask.qcloudimg.com/http-save/yehe-1987089/1bf55a9618ea4831f90412f31fbc8793.jpeg?imageView2/2/w/1200)

冒泡和捕获是两个不同的阶段

冒泡：事件由dom树从下往上执行，以点击事件为例，当我们点击子元素也能触发父元素的事件

捕获：事件由dom树从上往下执行， 当一个子元素绑定了点击事件，点击了子元素是，父元素以上的元素绑定的点击事件也会执行